# üß† Binary Search ( Question Pattern Identification)
Binary Search is more than searching in sorted arrays. Many problems involve searching over *answers*, *positions*, or even *conditions*. 
- [‚úÖ When to Use Binary Search](#-when-to-use-binary-search)
- [üß© Common Patterns](#-common-patterns)
- [üí° Tips](#-tips)
- [üìö Practice Problems](#-practice-problems)


## ‚úÖ When to Use Binary Search
- Array is **sorted** or has **monotonic behavior**.
  - "Find the first/last occurrence"
  - "Minimize/Maximize something"
  - "Find an index/value under constraints"
- Linear approach is too slow ‚Üí Think `O(log N)`.

## üß© Common Patterns

| Pattern                            | Use Case Example                                                  |
|------------------------------------|-------------------------------------------------------------------|
| **Classic Binary Search**          | Search for a value in a sorted array                             |
| **First/Last Occurrence**          | Boundaries, range counts                                         |
| **Search on Answer (Parametric)**  | Find smallest/largest valid answer (min/max speed, time, etc.)   |
| **Rotated Sorted Array**           | Pivoted sorted arrays                                            |
| **2D Binary Search**               | Search inside a matrix                                           |
| **Peak Element / Inflection**      | Local maxima/minima in array                                     |

## üí° Tips
- Binary Search works when the **search space is monotonic**.
- Use `low + (high - low) / 2` to avoid overflow.
- Modify conditions to suit problem:
  - Search on index? ‚Üí Binary search on `array`
  - Search on answer? ‚Üí Binary search on `value range`
- Consider variants like:
  - Lower Bound (first true condition)
  - Upper Bound (last true condition)

## üìö Practice Problems

<details>
<summary><strong>üîç Classic Binary Search</strong></summary>

- [ ] [704. Binary Search](https://leetcode.com/problems/binary-search/)
- [ ] [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)
- [ ] [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)


**Generic Codes**

- **Binary Search**
```cpp
int search(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```
---
- **Search Insert Position** 
```cpp
int searchInsert(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return low; // where it should be inserted
}
```
---
- **Find First BadVersion**   -- code can be help to find the first occurance of some element.
```cpp
// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

int firstBadVersion(int n) {
    int low = 1, high = n;
    while (low < high) {
        int mid = low + (high - low) / 2;

        if (isBadVersion(mid)) {
            high = mid; // the first bad is at mid or before
        } else {
            low = mid + 1; // bad version must be after mid
        }
    }
    return low; // or return high, both are same here
}
// WE CLUBBED HIGH = MID kyuki repeat horaha tha....
            // if(isBadVersion(mid)== true) high = mid;  
            // else if (isBadVersion(mid) == false) low =  mid+1 ; 
            // else    high = mid ;
```  
</details>




<details>
<summary><strong>üß≠ First / Last Occurrence</strong></summary>

- [ ] [34. Find First and Last Position of Element](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [ ] [852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)

**Find First and Last Position of Element**
```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res ; 
        res.push_back(firstoccurance( nums, target)) ; 
        res.push_back(lastoccurance( nums, target)) ; 
        return res  ; 
    }

    int firstoccurance(vector<int> &nums, int target)
    {
        int low = 0 ;
        int res =  -1;
        int high = nums.size()-1 ; 
        while(low<=high)
        {
            int mid  = low +(high-low)/2 ;
            if(nums[mid]==target){
            res = mid ;  
            high = mid-1 ;
            }
            else if (nums[mid]<target) {
                low =  mid+1 ;
            }
            else{
                high = mid-1 ;
            }
        }
        return res ;    
    }
    int lastoccurance(vector<int> &nums, int target)
    {
        int low = 0 ;
        int high = nums.size()-1 ; 
        int res =  -1;
        while(low<=high)
        {
            int mid  = low +(high-low)/2 ;
            if(nums[mid]==target)
            {
                res = mid ; 
                low  = mid +1 ; 
            }
            else if (nums[mid]<target)
            {
                low = mid +1 ; 
            }
            else{
                high  =  mid -1 ; 
            }
        }
        return res ;    
    }
};
```
---

**Peak Index in a Mountain Array**  
‚úÖ **while (low <= high):**  Standard Binary Search for Exact Match  
‚úÖ **while (low < high):**   Search for Boundary (Min, Max, First, Last, Peak)
```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int max  = 0 ; 
        int low =0; 
        int high =arr.size()-1 ;
        while(low<high)
        {
            int mid = low +(high-low)/2 ;
            if(arr[mid] < arr[mid+1])
            {
                low = mid + 1; 
            }
            else{
                high = mid ; 
            }
        }
        return low  ;
    }
};

// Why (low<high) is better here:
// You‚Äôre not looking for an exact match, you're shrinking the range to a single point (where low == high), then returning it.
```
</details>

<details>
<summary><strong>üîÑ Rotated Sorted Array</strong></summary>

- [ ] [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [ ] [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)
- [ ] [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

Context ke liye -- how do we K-Rotate an Array 
```cpp
void rotate(vector<int>& nums, int k) {
    int n = nums.size();
    k = k % n;  // effective rotation steps (wrap-around)
    reverse(nums.begin(), nums.end());
    reverse(nums.begin(), nums.begin() + k);
    reverse(nums.begin() + k, nums.end());
}
// Original:             [1, 2, 3, 4, 5, 6, 7],  
// Reverse whole array:  [7, 6, 5, 4, 3, 2, 1],
// Reverse first k=3 ele:[5, 6, 7, 4, 3, 2, 1],
// Reverse n - k = 4 ele:[5, 6, 7, 1, 2, 3, 4]
```
```cpp
int findRotationCount(vector<int>& arr) {
    int low = 0, high = arr.size() - 1;
    int n = arr.size();

    while (low <= high) {
        // If array is already sorted
        if (arr[low] <= arr[high])
            return low;

        int mid = low + (high - low) / 2;      // Need this two extra pointers 'prev' and 'next'
        int prev = (mid - 1) % n;              // for carefulness we can do  int prev = (mid -1 + n)%n ; 
        int next = (mid + 1) % n;

        if (arr[mid] <= arr[prev] && arr[mid] <= arr[next])    // Found the pivot
            return mid;
        
        if (arr[low] <= arr[mid])                            // Left part is sorted
            low = mid + 1;
        else
            high = mid - 1;
    }
    return 0;
}
```

</details>

<details>
<summary><strong>üìê Search on Answer (Parametric)</strong></summary>

- [ ] [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)
- [ ] [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)
- [ ] [1283. Minimum Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)
- [ ] [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)

</details>

<details>
<summary><strong>üßÆ Matrix Binary Search</strong></summary>

- [ ] [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)
- [ ] [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)

</details>

<details>
<summary><strong>üìà Advanced / Variants</strong></summary>

- [ ] [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)
- [ ] [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) *(Hard)*

</details>
